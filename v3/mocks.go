// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package main

import (
	"github.com/gonzaloserrano/go-hex-arch-example/v3/app"
	"sync"
)

var (
	lockCounterRepositoryMockFindByID sync.RWMutex
	lockCounterRepositoryMockUpsert   sync.RWMutex
)

// Ensure, that CounterRepositoryMock does implement app.CounterRepository.
// If this is not the case, regenerate this file with moq.
var _ app.CounterRepository = &CounterRepositoryMock{}

// CounterRepositoryMock is a mock implementation of app.CounterRepository.
//
//     func TestSomethingThatUsesCounterRepository(t *testing.T) {
//
//         // make and configure a mocked app.CounterRepository
//         mockedCounterRepository := &CounterRepositoryMock{
//             FindByIDFunc: func(ID string) app.Counter {
// 	               panic("mock out the FindByID method")
//             },
//             UpsertFunc: func(c app.Counter)  {
// 	               panic("mock out the Upsert method")
//             },
//         }
//
//         // use mockedCounterRepository in code that requires app.CounterRepository
//         // and then make assertions.
//
//     }
type CounterRepositoryMock struct {
	// FindByIDFunc mocks the FindByID method.
	FindByIDFunc func(ID string) app.Counter

	// UpsertFunc mocks the Upsert method.
	UpsertFunc func(c app.Counter)

	// calls tracks calls to the methods.
	calls struct {
		// FindByID holds details about calls to the FindByID method.
		FindByID []struct {
			// ID is the ID argument value.
			ID string
		}
		// Upsert holds details about calls to the Upsert method.
		Upsert []struct {
			// C is the c argument value.
			C app.Counter
		}
	}
}

// FindByID calls FindByIDFunc.
func (mock *CounterRepositoryMock) FindByID(ID string) app.Counter {
	if mock.FindByIDFunc == nil {
		panic("CounterRepositoryMock.FindByIDFunc: method is nil but CounterRepository.FindByID was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: ID,
	}
	lockCounterRepositoryMockFindByID.Lock()
	mock.calls.FindByID = append(mock.calls.FindByID, callInfo)
	lockCounterRepositoryMockFindByID.Unlock()
	return mock.FindByIDFunc(ID)
}

// FindByIDCalls gets all the calls that were made to FindByID.
// Check the length with:
//     len(mockedCounterRepository.FindByIDCalls())
func (mock *CounterRepositoryMock) FindByIDCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	lockCounterRepositoryMockFindByID.RLock()
	calls = mock.calls.FindByID
	lockCounterRepositoryMockFindByID.RUnlock()
	return calls
}

// Upsert calls UpsertFunc.
func (mock *CounterRepositoryMock) Upsert(c app.Counter) {
	if mock.UpsertFunc == nil {
		panic("CounterRepositoryMock.UpsertFunc: method is nil but CounterRepository.Upsert was just called")
	}
	callInfo := struct {
		C app.Counter
	}{
		C: c,
	}
	lockCounterRepositoryMockUpsert.Lock()
	mock.calls.Upsert = append(mock.calls.Upsert, callInfo)
	lockCounterRepositoryMockUpsert.Unlock()
	mock.UpsertFunc(c)
}

// UpsertCalls gets all the calls that were made to Upsert.
// Check the length with:
//     len(mockedCounterRepository.UpsertCalls())
func (mock *CounterRepositoryMock) UpsertCalls() []struct {
	C app.Counter
} {
	var calls []struct {
		C app.Counter
	}
	lockCounterRepositoryMockUpsert.RLock()
	calls = mock.calls.Upsert
	lockCounterRepositoryMockUpsert.RUnlock()
	return calls
}
